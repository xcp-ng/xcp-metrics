/*!
# Metrics Hub

This is the part that centralize the metrics from the main daemon.
It communicates metrics with [crate::publishers] (pull) and [crate::providers] (push) using a [`mpsc::UnboundedSender<HubPullResponse>`].

All metrics are uniquely identified using a [uuid::Uuid] to ease updating, this identifier must be generated by the provider (using [uuid::Uuid::new_v4]).
*/
use std::sync::Arc;

use tokio::{
    sync::mpsc,
    task::{self, JoinHandle},
};
use xcp_metrics_common::metrics::{Metric, MetricFamily, MetricPoint, MetricSet, MetricType};

/// Register a new metric family to the hub.
#[derive(Debug, Clone)]
pub struct CreateFamily {
    pub name: Box<str>,
    pub metric_type: MetricType,
    pub unit: Box<str>,
    pub help: Box<str>,
}

/// Register a new metric to the hub.
#[derive(Debug, Clone)]
pub struct RegisterMetrics {
    pub family: Box<str>,
    pub metrics: Metric,
    pub uuid: uuid::Uuid,
}

/// Remove a metric from the hub.
#[derive(Debug, Clone)]
pub struct UnregisterMetrics {
    pub uuid: uuid::Uuid,
}

/// Replace the values of a metric.
#[derive(Debug, Clone)]
pub struct UpdateMetrics {
    pub uuid: uuid::Uuid,
    pub new_values: Box<[MetricPoint]>,
}

/// Fetch metrics, receiving them in a provided [`mpsc::UnboundedSender<HubPullResponse>`].
#[derive(Debug, Clone)]
pub struct PullMetrics(pub mpsc::UnboundedSender<HubPullResponse>);

/// A message that can be sent to the hub.
#[derive(Debug, Clone)]
pub enum HubPushMessage {
    CreateFamily(CreateFamily),
    RegisterMetrics(RegisterMetrics),
    UnregisterMetrics(UnregisterMetrics),
    UpdateMetrics(UpdateMetrics),
    PullMetrics(PullMetrics),
}

/// A hub response.
#[derive(Debug, Clone)]
pub enum HubPullResponse {
    Metrics(Arc<MetricSet>),
}

/// Metrics Hub
#[derive(Debug, Clone, Default)]
pub struct MetricsHub {
    metrics: Arc<MetricSet>,
}

impl MetricsHub {
    /// Starts the Metrics Hub in a new [tokio::task], giving the associated [JoinHandle] and hub channel ([`mpsc::UnboundedSender<HubPushMessage>`]).
    pub async fn start(self) -> (JoinHandle<()>, mpsc::UnboundedSender<HubPushMessage>) {
        let (sender, receiver) = mpsc::unbounded_channel();
        let mut rendez_vous = mpsc::channel(1);

        let handle = task::spawn(async move { self.run(receiver, rendez_vous.0).await });

        rendez_vous.1.recv().await;

        tracing::info!("Hub ready");

        (handle, sender)
    }

    async fn run(
        mut self,
        mut receiver: mpsc::UnboundedReceiver<HubPushMessage>,
        rendez_vous: mpsc::Sender<()>,
    ) {
        rendez_vous.send(()).await.unwrap();

        while let Some(msg) = receiver.recv().await {
            match msg {
                HubPushMessage::CreateFamily(message) => self.create_family(message).await,
                HubPushMessage::RegisterMetrics(message) => self.register(message).await,
                HubPushMessage::UnregisterMetrics(message) => self.unregister(message).await,
                HubPushMessage::UpdateMetrics(message) => self.update(message).await,
                HubPushMessage::PullMetrics(message) => self.pull_metrics(message).await,
            }
        }
    }

    #[tracing::instrument(skip(self))]
    async fn create_family(
        &mut self,
        CreateFamily {
            name,
            metric_type,
            unit,
            help,
        }: CreateFamily,
    ) {
        let metrics = Arc::make_mut(&mut self.metrics);
        
        if let Some(old_family) = metrics.families.insert(
            name,
            MetricFamily {
                metric_type,
                unit,
                help,
                metrics: Default::default(),
            },
        ) {
            tracing::warn!("Overriden previous family: {old_family:?}");
        }

        tracing::debug!("Inserted family");
    }

    #[tracing::instrument(skip(self))]
    async fn register(&mut self, message: RegisterMetrics) {
        let metrics = Arc::make_mut(&mut self.metrics);

        let family = match metrics.families.get_mut(&message.family) {
            Some(f) => f,
            None => {
                tracing::warn!("Missing family, creating default one");

                metrics
                    .families
                    .insert(message.family.clone(), Default::default());
                metrics.families.get_mut(&message.family).unwrap()
            }
        };

        if let Some(old) = family.metrics.insert(message.uuid, message.metrics) {
            tracing::warn!("Overriden {old:?}");
        }
    }

    #[tracing::instrument(skip(self))]
    async fn unregister(&mut self, message: UnregisterMetrics) {
        let metrics = Arc::make_mut(&mut self.metrics);
        let mut deprecated_family = None;

        for (family_name, family) in metrics.families.iter_mut() {
            if family.metrics.remove(&message.uuid).is_some() {
                tracing::info!("Unregistered {}", message.uuid);

                // Remove metric family if now empty.
                if family.metrics.is_empty() {
                    deprecated_family.replace(family_name.clone());
                }

                break;
            }
        }

        if let Some(name) = &deprecated_family {
            tracing::info!("Unregistered empty metric family {name}");
            metrics.families.remove(name);
        }
    }

    #[tracing::instrument(skip(self))]
    async fn update(&mut self, mut message: UpdateMetrics) {
        let metrics = Arc::make_mut(&mut self.metrics);

        // TODO: Do some checks.

        for (_, family) in metrics.families.iter_mut() {
            if let Some(metrics) = family.metrics.get_mut(&message.uuid) {
                tracing::debug!("Metric {} properly updated", message.uuid);

                /* Rust wizardry */
                std::mem::swap(&mut metrics.metrics_point, &mut message.new_values);
                break;
            }
        }
    }

    #[tracing::instrument(skip(self))]
    async fn pull_metrics(&mut self, message: PullMetrics) {
        let sender = message.0;
        tracing::debug!("Pulling metrics");

        if let Err(e) = sender.send(HubPullResponse::Metrics(Arc::clone(&self.metrics))) {
            tracing::error!("Error occured while sending metrics {e}");
        }
    }
}
